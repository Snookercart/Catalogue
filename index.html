<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flipbook Fullscreen + Zoom</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; background: #fff; overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    :root { --vh: 1vh; }
    body {
      display: flex; justify-content: center; align-items: center; flex-direction: column;
      touch-action: none;
    }
    #loading {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-size: 1.5em; color: #555;
    }
    #book {
      position: relative;
      width: 90vw;
      max-width: 1000px;
      height: 90vh;
      perspective: 2000px;
      overflow: hidden;
      display: none; /* hidden until loaded */
    }
    #book.fullscreen {
      width: 100vw;
      height: calc(var(--vh, 1vh) * 100);
    }
    .page {
      position: absolute;
      width: 100%;
      height: 100%;
      background: white;
      transform-origin: left center;
      transform-style: preserve-3d;
      transition: transform 1s ease;
      overflow: hidden;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
    }
    .page.flipped {
      transform: rotateY(-180deg);
    }
    .page-inner {
      width: 100%;
      height: 100%;
      overflow: hidden;
      position: relative;
      touch-action: none;
      cursor: grab;
    }
    .page-inner:active {
      cursor: grabbing;
    }
    .page-inner img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
      transform-origin: center center;
      transition: transform 0.2s ease;
      user-select: none;
      -webkit-user-drag: none;
      pointer-events: none;
    }
    .nav {
      position: absolute;
      top: 0;
      width: 50%;
      height: 100%;
      z-index: 100;
    }
    .nav.left { left: 0; }
    .nav.right { right: 0; }
    .controls {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 200;
      display: none;
    }
    .btn {
      padding: 8px 14px;
      border: none;
      background: rgba(0,0,0,0.7);
      color: #fff;
      font-size: 14px;
      border-radius: 6px;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <div id="loading">Loading pages, please wait...</div>

  <div id="book"></div>
  <div class="nav left"></div>
  <div class="nav right"></div>

  <div class="controls">
    <button class="btn" id="toggleView">Enter Fullscreen</button>
  </div>

  <script>
    const totalPages = 10;
    const book = document.getElementById("book");
    const loading = document.getElementById("loading");
    const controls = document.querySelector(".controls");
    const toggleBtn = document.getElementById("toggleView");
    let current = 0;

    // Preload images
    function preloadImages() {
      let loadedCount = 0;
      const imgs = [];
      return new Promise(resolve => {
        for (let i = 1; i <= totalPages; i++) {
          const img = new Image();
          img.src = `page_${String(i).padStart(3, "0")}.png`;
          img.onload = () => {
            loadedCount++;
            if (loadedCount === totalPages) resolve(imgs);
          };
          img.onerror = () => {
            console.warn("Error loading image", img.src);
            loadedCount++;
            if (loadedCount === totalPages) resolve(imgs);
          };
          imgs.push(img);
        }
      });
    }

    preloadImages().then(images => {
      // Show book and controls
      loading.style.display = 'none';
      controls.style.display = 'block';
      book.style.display = 'block';

      // Build pages
      images.forEach((imgElement, index) => {
        const page = document.createElement("div");
        page.className = "page";
        page.style.zIndex = totalPages - index;

        const inner = document.createElement("div");
        inner.className = "page-inner";

        const img = imgElement;
        img.alt = `Page ${index + 1}`;
        img.style.userSelect = 'none';
        img.style.webkitUserDrag = 'none';
        img.style.pointerEvents = 'none';

        inner.appendChild(img);
        page.appendChild(inner);
        book.appendChild(page);

        setupZoom(inner, img);
      });

      showPage(0);

      // Auto‑enter fullscreen on first interaction
      function enterFullscreenOnFirstInteraction() {
        const handler = () => {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
              console.warn("Fullscreen request failed:", err);
            });
          }
          book.classList.add("fullscreen");
          toggleBtn.textContent = "Exit Fullscreen";
          // Remove the event listeners so it only triggers once
          document.removeEventListener("click", handler);
          document.removeEventListener("touchstart", handler);
        }
        document.addEventListener("click", handler, { once: true });
        document.addEventListener("touchstart", handler, { once: true });
      }

      enterFullscreenOnFirstInteraction();
    });

    function pages() {
      return document.querySelectorAll(".page");
    }

    function showPage(n) {
      if (n < 0) n = 0;
      if (n >= totalPages) n = totalPages - 1;
      current = n;
      pages().forEach((page, idx) => {
        page.classList.toggle("flipped", idx < n);
        // Reset zoom/pan
        const inner = page.querySelector('.page-inner');
        const img = page.querySelector('img');
        img.style.transition = 'transform 0.2s ease';
        img.style.transform = 'translate(0px, 0px) scale(1)';
        inner.dataset.scale = 1;
        inner.dataset.posX = 0;
        inner.dataset.posY = 0;
      });
    }

    document.querySelector(".nav.right").addEventListener("click", () => {
      if (current < totalPages - 1) showPage(current + 1);
    });
    document.querySelector(".nav.left").addEventListener("click", () => {
      if (current > 0) showPage(current - 1);
    });

    toggleBtn.addEventListener("click", () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().then(() => {
          book.classList.add("fullscreen");
          toggleBtn.textContent = "Exit Fullscreen";
        });
      } else {
        document.exitFullscreen().then(() => {
          book.classList.remove("fullscreen");
          toggleBtn.textContent = "Enter Fullscreen";
        });
      }
    });

    function setViewportHeight() {
      let vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    }
    setViewportHeight();
    window.addEventListener('resize', setViewportHeight);

    function setupZoom(container, img) {
      container.dataset.scale = 1;
      container.dataset.posX = 0;
      container.dataset.posY = 0;

      let lastTouchTime = 0;
      let touchStartTime = 0;
      let touchStartX = 0;
      let touchStartY = 0;

      let pinchStartDistance = 0;
      let pinchStartScale = 1;

      function clamp(val, min, max) { return Math.min(Math.max(val, min), max); }

      function updateTransform() {
        const scale = parseFloat(container.dataset.scale);
        const posX = parseFloat(container.dataset.posX);
        const posY = parseFloat(container.dataset.posY);
        img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
      }

      function resetZoom() {
        container.dataset.scale = 1;
        container.dataset.posX = 0;
        container.dataset.posY = 0;
        updateTransform();
      }

      function distanceBetweenTouches(t1, t2) {
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        return Math.sqrt(dx*dx + dy*dy);
      }

      container.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          touchStartTime = Date.now();
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
          e.preventDefault();
          pinchStartDistance = distanceBetweenTouches(e.touches[0], e.touches[1]);
          pinchStartScale = parseFloat(container.dataset.scale);
        }
      }, { passive: false });

      container.addEventListener('touchend', (e) => {
        const now = Date.now();
        if (e.changedTouches.length === 1) {
          const dt = now - touchStartTime;
          const dx = e.changedTouches[0].clientX - touchStartX;
          const dy = e.changedTouches[0].clientY - touchStartY;
          const moveDist = Math.sqrt(dx*dx + dy*dy);
          if (dt < 250 && moveDist < 10) {
            // Recognize as tap
            if (now - lastTouchTime < 300) {
              // double‑tap
              e.preventDefault();
              const currentScale = parseFloat(container.dataset.scale);
              if (currentScale === 1) {
                container.dataset.scale = 2;
              } else {
                resetZoom();
              }
              updateTransform();
            }
            lastTouchTime = now;
          }
        }
      });

      container.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
          e.preventDefault();
          const newDistance = distanceBetweenTouches(e.touches[0], e.touches[1]);
          let scaleFactor = newDistance / pinchStartDistance;
          let newScale = clamp(pinchStartScale * scaleFactor, 1, 4);
          container.dataset.scale = newScale;
          updateTransform();
        } else if (e.touches.length === 1) {
          const currentScale = parseFloat(container.dataset.scale);
          if (currentScale > 1) {
            e.preventDefault();
            const touch = e.touches[0];
            const lastX = parseFloat(container.dataset.posX);
            const lastY = parseFloat(container.dataset.posY);
            // Using clientX clientY directly for pan is simple
            // but could track delta
            // For simplicity, treat this as small pan per move
            // Could refine if needed
            const dx = touch.clientX - touchStartX;
            const dy = touch.clientY - touchStartY;
            container.dataset.posX = lastX + dx;
            container.dataset.posY = lastY + dy;
            updateTransform();
            // update start for next move
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
          }
        }
      }, { passive: false });

      // Double‑click for desktop
      container.addEventListener('dblclick', (e) => {
        e.preventDefault();
        const currentScale = parseFloat(container.dataset.scale);
        if (currentScale === 1) {
          container.dataset.scale = 2;
        } else {
          resetZoom();
        }
        updateTransform();
      });
    }
  </script>

</body>
</html>
