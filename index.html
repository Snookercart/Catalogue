<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Catalogue Flipbook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style>
    :root { --vh: 1vh; --arrow-size: 64px; --control-gap: 10px; }
    html,body { height:100%; margin:0; padding:0; -webkit-font-smoothing:antialiased; }
    body {
      display:flex; align-items:center; justify-content:center; flex-direction:column;
      background:#fff; overflow:hidden; touch-action:none; user-select:none;
    }

    #loading {
      position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:500;
      font-size:1.1rem; color:#444;
    }

    #book {
      width:100vw; height:calc(var(--vh,1vh) * 100); perspective:2000px;
      position:relative; overflow:hidden; display:none;
    }

    .page {
      position:absolute; width:100%; height:100%; transform-origin:left center;
      transform-style:preserve-3d; transition:transform 1s ease; background:white;
      box-shadow:0 6px 20px rgba(0,0,0,0.12);
    }
    .page.flipped { transform:rotateY(-180deg); }

    .page-inner {
      position:relative; width:100%; height:100%;
      display:flex; align-items:center; justify-content:center; overflow:hidden;
      touch-action:none;
    }

    /* image is centered & contained; pointer-events none so events fall to the container */
    .page-inner img {
      max-width:100%; max-height:100%;
      object-fit:contain; transform-origin:center center;
      user-select:none; pointer-events:none; touch-action:none;
      will-change:transform;
    }

    /* big left/right overlay arrows like your screenshot */
    .nav-arrow {
      position:absolute; top:50%; width:var(--arrow-size); height:var(--arrow-size);
      transform:translateY(-50%); z-index:400; display:flex; align-items:center; justify-content:center;
      background:rgba(255,255,255,0.85); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.12);
      cursor:pointer; user-select:none;
    }
    .nav-arrow.left { left:12px; }
    .nav-arrow.right { right:12px; }

    .nav-arrow svg { width:36px; height:36px; display:block; }

    /* controls at bottom: zoom in/out/reset & fullscreen toggle */
    .controls {
      position:fixed; left:50%; bottom:14px; transform:translateX(-50%); z-index:450;
      display:flex; gap:var(--control-gap); align-items:center;
    }
    .btn {
      padding:8px 12px; border-radius:8px; background:rgba(0,0,0,0.75);
      color:white; border:none; font-size:14px; cursor:pointer;
    }

    /* small page index */
    .page-index {
      position:fixed; left:14px; bottom:14px; z-index:450; background:rgba(0,0,0,0.6);
      color:#fff; padding:6px 10px; border-radius:8px; font-size:13px;
    }

    @media (max-width:520px) {
      :root { --arrow-size:48px; }
      .nav-arrow { width:var(--arrow-size); height:var(--arrow-size); }
    }
  </style>
</head>
<body>
  <div id="loading">Loading catalogue...</div>

  <div id="book" aria-label="Flipbook container"></div>

  <div class="nav-arrow left" id="navLeft" title="Previous page" role="button" tabindex="0">
    <!-- left arrow -->
    <svg viewBox="0 0 24 24" fill="none" stroke="#222" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="15 18 9 12 15 6"></polyline>
    </svg>
  </div>

  <div class="nav-arrow right" id="navRight" title="Next page" role="button" tabindex="0">
    <!-- right arrow -->
    <svg viewBox="0 0 24 24" fill="none" stroke="#222" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </div>

  <div class="controls" aria-hidden="false">
    <button class="btn" id="zoomOut" title="Zoom out">−</button>
    <button class="btn" id="zoomReset" title="Reset zoom">Reset</button>
    <button class="btn" id="zoomIn" title="Zoom in">+</button>
    <button class="btn" id="toggleView">Enter Fullscreen</button>
  </div>

  <div class="page-index" id="pageIndex">Page 1 / 10</div>

  <script>
    /* ==== CONFIG ==== */
    const totalPages = 10;          // update if you have different number
    const minScale = 1;
    const maxScale = 4;
    const doubleTapDelay = 300;    // ms
    const zoomStep = 1.25;         // factor for +/-
    /* ================ */

    const book = document.getElementById('book');
    const loading = document.getElementById('loading');
    const navLeft = document.getElementById('navLeft');
    const navRight = document.getElementById('navRight');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const zoomResetBtn = document.getElementById('zoomReset');
    const toggleViewBtn = document.getElementById('toggleView');
    const pageIndexEl = document.getElementById('pageIndex');

    let current = 0; // visible page index (0 .. totalPages-1)
    const pages = [];

    // track pointer for wheel interactions
    let pointerOverBook = false;

    // set CSS var for vh (mobile address bars)
    function setVH() {
      document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`);
    }
    window.addEventListener('resize', setVH);
    setVH();

    // preload images -> resolves after load/error of all
    function preloadImages() {
      let loaded = 0;
      return new Promise(resolve => {
        for (let i = 1; i <= totalPages; i++) {
          const img = new Image();
          img.src = `page_${String(i).padStart(3, '0')}.png`;
          img.onload = img.onerror = () => {
            loaded++;
            if (loaded === totalPages) resolve();
          };
        }
      });
    }

    // create page DOM and setup handlers
    function createPages() {
      for (let i = 0; i < totalPages; i++) {
        const page = document.createElement('div');
        page.className = 'page';
        page.style.zIndex = totalPages - i;
        page.dataset.index = i;

        const inner = document.createElement('div');
        inner.className = 'page-inner';
        // persistent states
        inner.dataset.scale = '1';
        inner.dataset.posX = '0';
        inner.dataset.posY = '0';
        inner.dataset.baseW = '0';
        inner.dataset.baseH = '0';

        const img = document.createElement('img');
        img.alt = `Page ${i + 1}`;
        img.src = `page_${String(i + 1).padStart(3, '0')}.png`;

        // when natural size available, compute base display size (contain)
        img.addEventListener('load', () => {
          updateBaseImageSize(inner, img);
        });

        // recalc base on window resize (in case viewport changed)
        const onResizeForThis = () => updateBaseImageSize(inner, img);
        window.addEventListener('resize', onResizeForThis);

        inner.appendChild(img);
        page.appendChild(inner);
        book.appendChild(page);

        setupInteraction(inner, img, i);

        pages.push({page, inner, img, onResizeForThis});
      }
    }

    // compute how big image will be when "contain" inside container (scale = 1)
    function updateBaseImageSize(container, img) {
      const cw = container.clientWidth;
      const ch = container.clientHeight;
      const nw = img.naturalWidth || 1;
      const nh = img.naturalHeight || 1;
      const containerRatio = cw / ch;
      const imageRatio = nw / nh;
      let baseW, baseH;
      if (imageRatio > containerRatio) {
        baseW = cw;
        baseH = cw / imageRatio;
      } else {
        baseH = ch;
        baseW = ch * imageRatio;
      }
      container.dataset.baseW = String(baseW);
      container.dataset.baseH = String(baseH);
      // if scale is 1, ensure transform stays centered
      if (parseFloat(container.dataset.scale || '1') === 1) {
        container.dataset.posX = '0';
        container.dataset.posY = '0';
        applyTransform(container);
      } else {
        // clamp existing translate values within new bounds
        clampTranslate(container);
        applyTransform(container);
      }
    }

    // apply CSS transform to the <img> inside container
    function applyTransform(container) {
      const img = container.querySelector('img');
      const scale = parseFloat(container.dataset.scale || '1');
      const x = parseFloat(container.dataset.posX || '0');
      const y = parseFloat(container.dataset.posY || '0');
      // use translate then scale; img is centered via flexbox so translate moves from center
      img.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
    }

    // clamp posX/posY to keep the zoomed image inside bounds
    function clampTranslate(container) {
      const cw = container.clientWidth;
      const ch = container.clientHeight;
      const baseW = parseFloat(container.dataset.baseW || '0');
      const baseH = parseFloat(container.dataset.baseH || '0');
      const scale = parseFloat(container.dataset.scale || '1');

      const scaledW = baseW * scale;
      const scaledH = baseH * scale;

      const halfOverflowX = Math.max(0, (scaledW - cw) / 2);
      const halfOverflowY = Math.max(0, (scaledH - ch) / 2);

      let x = parseFloat(container.dataset.posX || '0');
      let y = parseFloat(container.dataset.posY || '0');

      x = Math.max(-halfOverflowX, Math.min(halfOverflowX, x));
      y = Math.max(-halfOverflowY, Math.min(halfOverflowY, y));

      container.dataset.posX = String(x);
      container.dataset.posY = String(y);
    }

    // reset zoom to default
    function resetZoom(container) {
      container.dataset.scale = '1';
      container.dataset.posX = '0';
      container.dataset.posY = '0';
      applyTransform(container);
    }

    // Setup all interactions (pinch, pan, dbltap, wheel, buttons). idx is page index
    function setupInteraction(container, img, idx) {
      let lastTap = 0;
      let pinchStartDist = 0;
      let pinchStartScale = 1;
      let startX = 0, startY = 0;
      let isPanning = false;

      // Helper: only allow interactions for current page
      function isActive() {
        return idx === current;
      }

      // pointer presence tracking
      container.addEventListener('pointerenter', () => { pointerOverBook = true; });
      container.addEventListener('pointerleave', () => { pointerOverBook = false; });

      // touchstart
      container.addEventListener('touchstart', (e) => {
        if (!isActive()) return;
        if (e.touches.length === 2) {
          pinchStartDist = getDist(e.touches[0], e.touches[1]);
          pinchStartScale = parseFloat(container.dataset.scale || '1');
        } else if (e.touches.length === 1) {
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
          isPanning = true;
        }
      }, { passive: false });

      // touchmove
      container.addEventListener('touchmove', (e) => {
        if (!isActive()) return;
        if (e.touches.length === 2) {
          e.preventDefault();
          const dist = getDist(e.touches[0], e.touches[1]);
          let newScale = pinchStartScale * (dist / pinchStartDist);
          newScale = Math.max(minScale, Math.min(maxScale, newScale));
          container.dataset.scale = String(newScale);
          clampTranslate(container);
          applyTransform(container);
        } else if (e.touches.length === 1) {
          const scale = parseFloat(container.dataset.scale || '1');
          if (scale > 1 && isPanning) {
            e.preventDefault();
            const dx = e.touches[0].clientX - startX;
            const dy = e.touches[0].clientY - startY;
            container.dataset.posX = String(parseFloat(container.dataset.posX || '0') + dx);
            container.dataset.posY = String(parseFloat(container.dataset.posY || '0') + dy);
            clampTranslate(container);
            applyTransform(container);
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
          }
        }
      }, { passive: false });

      container.addEventListener('touchend', (e) => {
        if (!isActive()) return;
        isPanning = false;
        const now = Date.now();
        // detect double-tap
        if (now - lastTap < doubleTapDelay) {
          const scale = parseFloat(container.dataset.scale || '1');
          if (scale === 1) {
            container.dataset.scale = '2';
          } else {
            container.dataset.scale = '1';
            container.dataset.posX = '0';
            container.dataset.posY = '0';
          }
          clampTranslate(container);
          applyTransform(container);
          lastTap = 0;
        } else {
          lastTap = now;
        }
      });

      // dblclick for desktop
      container.addEventListener('dblclick', (e) => {
        if (!isActive()) return;
        e.preventDefault();
        const scale = parseFloat(container.dataset.scale || '1');
        if (scale === 1) {
          container.dataset.scale = '2';
        } else {
          container.dataset.scale = '1';
          container.dataset.posX = '0';
          container.dataset.posY = '0';
        }
        clampTranslate(container);
        applyTransform(container);
      });

      // pointer down/up/move for mouse panning
      let mouseDown = false;
      container.addEventListener('pointerdown', (e) => {
        if (!isActive()) return;
        if (e.pointerType === 'mouse' && e.button !== 0) return; // only left button
        mouseDown = true;
        startX = e.clientX;
        startY = e.clientY;
        container.setPointerCapture && container.setPointerCapture(e.pointerId);
      });
      container.addEventListener('pointermove', (e) => {
        if (!isActive()) return;
        if (!mouseDown) return;
        const scale = parseFloat(container.dataset.scale || '1');
        if (scale > 1) {
          e.preventDefault();
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          container.dataset.posX = String(parseFloat(container.dataset.posX || '0') + dx);
          container.dataset.posY = String(parseFloat(container.dataset.posY || '0') + dy);
          clampTranslate(container);
          applyTransform(container);
          startX = e.clientX;
          startY = e.clientY;
        }
      });
      container.addEventListener('pointerup', (e) => {
        if (!isActive()) return;
        mouseDown = false;
        try { container.releasePointerCapture && container.releasePointerCapture(e.pointerId); } catch(e){}
      });
      container.addEventListener('pointercancel', () => { mouseDown = false; });

      // wheel zoom (desktop) — only when pointer over this container
      container.addEventListener('wheel', (e) => {
        if (!isActive()) return;
        // allow normal scroll outside book; prevent default here
        e.preventDefault();
        const delta = e.deltaY;
        let scale = parseFloat(container.dataset.scale || '1');
        if (delta < 0) scale *= 1.08;
        else scale /= 1.08;
        scale = Math.max(minScale, Math.min(maxScale, scale));
        container.dataset.scale = String(scale);
        // optionally adjust translate to zoom toward cursor (nice-to-have) — simple version keeps center
        clampTranslate(container);
        applyTransform(container);
      }, { passive: false });

      // expose small API for external controls
      container._zoomIn = () => {
        if (!isActive()) return;
        let scale = parseFloat(container.dataset.scale || '1') * zoomStep;
        scale = Math.min(maxScale, scale);
        container.dataset.scale = String(scale);
        clampTranslate(container);
        applyTransform(container);
      };
      container._zoomOut = () => {
        if (!isActive()) return;
        let scale = parseFloat(container.dataset.scale || '1') / zoomStep;
        scale = Math.max(minScale, scale);
        container.dataset.scale = String(scale);
        if (scale === 1) { container.dataset.posX = '0'; container.dataset.posY = '0'; }
        clampTranslate(container);
        applyTransform(container);
      };
      container._resetZoom = () => { if (!isActive()) return; resetZoom(container); };
    }

    // utility: distance between two touch points
    function getDist(t1, t2) {
      const dx = t1.clientX - t2.clientX;
      const dy = t1.clientY - t2.clientY;
      return Math.sqrt(dx*dx + dy*dy);
    }

    /* ==== Page flipping and UI ==== */

    function showPage(n) {
      // clamp 0 .. totalPages-1
      current = Math.max(0, Math.min(n, totalPages - 1));
      pages.forEach((p, idx) => {
        p.page.classList.toggle('flipped', idx < current);
        // reset zoom for non-active pages
        if (idx !== current) {
          p.inner.dataset.scale = '1';
          p.inner.dataset.posX = '0';
          p.inner.dataset.posY = '0';
          p.img.style.transform = ''; // clear
        } else {
          // ensure base sizes available & clamp
          updateBaseImageSize(p.inner, p.img);
          clampTranslate(p.inner);
          applyTransform(p.inner);
        }
      });
      pageIndexEl.textContent = `Page ${current + 1} / ${totalPages}`;
      // enable/disable nav visibility as needed (optional)
      navLeft.style.opacity = current === 0 ? '0.35' : '1';
      navRight.style.opacity = current === totalPages - 1 ? '0.35' : '1';
    }

    function nextPage() { if (current < totalPages - 1) showPage(current + 1); }
    function prevPage() { if (current > 0) showPage(current - 1); }

    // wire nav arrow buttons
    navLeft.addEventListener('click', prevPage);
    navRight.addEventListener('click', nextPage);
    navLeft.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') prevPage(); });
    navRight.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') nextPage(); });

    // keyboard navigation & zoom shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight') nextPage();
      if (e.key === 'ArrowLeft') prevPage();
      if (e.key === '+' || e.key === '=' ) { // plus
        const active = pages[current]?.inner; active && active._zoomIn && active._zoomIn();
      }
      if (e.key === '-' || e.key === '_' ) {
        const active = pages[current]?.inner; active && active._zoomOut && active._zoomOut();
      }
      if (e.key === '0') { const active = pages[current]?.inner; active && active._resetZoom && active._resetZoom(); }
    });

    // bottom controls
    zoomInBtn.addEventListener('click', () => { const active = pages[current]?.inner; active && active._zoomIn && active._zoomIn(); });
    zoomOutBtn.addEventListener('click', () => { const active = pages[current]?.inner; active && active._zoomOut && active._zoomOut(); });
    zoomResetBtn.addEventListener('click', () => { const active = pages[current]?.inner; active && active._resetZoom && active._resetZoom(); });

    // fullscreen toggle
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(()=>{});
        toggleViewBtn.textContent = 'Exit Fullscreen';
      } else {
        document.exitFullscreen().catch(()=>{});
        toggleViewBtn.textContent = 'Enter Fullscreen';
      }
    }
    toggleViewBtn.addEventListener('click', toggleFullscreen);

    // show/hide book and init
    preloadImages().then(() => {
      createPages();
      loading.style.display = 'none';
      book.style.display = 'block';
      showPage(0);
      // auto-fullscreen on first interaction (keeps existing behavior)
      function autoFs() { toggleFullscreen(); document.removeEventListener('click', autoFs); document.removeEventListener('touchstart', autoFs); }
      document.addEventListener('click', autoFs, { once: true });
      document.addEventListener('touchstart', autoFs, { once: true });
    });

    // ensure when navigating pages using nav arrows we reset or clamp zoom on the new active page
    navLeft.addEventListener('click', () => {
      // small delay to allow CSS flip transition to complete visually, but we immediately reset/clamp to safe states
      setTimeout(() => showPage(current - 1), 0);
    });

    navRight.addEventListener('click', () => {
      setTimeout(() => showPage(current + 1), 0);
    });

    // Also allow clicking the left half / right half of the screen to flip (optional)
    book.addEventListener('click', (e) => {
      // ignore clicks when pointer is over the arrow controls or when zoom > 1 (so users can tap to pan)
      const activeInner = pages[current]?.inner;
      if (!activeInner) return;
      const scale = parseFloat(activeInner.dataset.scale || '1');
      if (scale > 1) return; // when zoomed, don't flip on tap
      const rect = book.getBoundingClientRect();
      const x = e.clientX - rect.left;
      if (x < rect.width * 0.3) prevPage();
      else if (x > rect.width * 0.7) nextPage();
    });

    // ensure pointerOverBook resets when leaving the whole book area
    book.addEventListener('pointerenter', () => pointerOverBook = true);
    book.addEventListener('pointerleave', () => pointerOverBook = false);

    // Clean up helper if you need to free listeners later
    // (not used here, but pages[] has references if needed)
  </script>
</body>
</html>
