<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flipbook with Preloaded Zoom</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; background: #fff; overflow: hidden;
      font-family: sans-serif;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    :root { --vh: 1vh; }
    body {
      display: flex; justify-content: center; align-items: center; flex-direction: column;
      touch-action: none;
    }
    #loading {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-size: 1.5em; color: #555;
    }
    #book {
      position: relative;
      width: 90vw;
      max-width: 1000px;
      height: 90vh;
      perspective: 2000px;
      transition: all 0.5s ease;
      overflow: hidden;
      display: none; /* hide until loaded */
    }
    #book.fullscreen {
      width: 100vw;
      height: calc(var(--vh, 1vh) * 100);
    }
    .page {
      position: absolute;
      width: 100%;
      height: 100%;
      background: white;
      transform-origin: left center;
      transform-style: preserve-3d;
      transition: transform 1s ease;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
      overflow: hidden;
    }
    .page.flipped {
      transform: rotateY(-180deg);
    }
    .page-inner {
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: none;
      transform-origin: center center;
      position: relative;
      cursor: grab;
    }
    .page-inner:active {
      cursor: grabbing;
    }
    .page-inner img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
      transform-origin: center center;
      user-select: none;
      -webkit-user-drag: none;
      pointer-events: none;
      transition: transform 0.15s ease;
    }
    .nav {
      position: absolute;
      top: 0;
      width: 50%;
      height: 100%;
      z-index: 100;
    }
    .nav.left { left: 0; }
    .nav.right { right: 0; }
    .controls {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 200;
    }
    .btn {
      padding: 8px 14px;
      border: none;
      background: rgba(0,0,0,0.7);
      color: #fff;
      font-size: 14px;
      border-radius: 6px;
      cursor: pointer;
    }
  </style>
</head>
<body>

<div id="loading">Loading pages, please wait...</div>

<div id="book"></div>
<div class="nav left"></div>
<div class="nav right"></div>

<div class="controls" style="display:none;">
  <button class="btn" id="toggleView">Enter Fullscreen</button>
</div>

<script>
  const totalPages = 10;
  const book = document.getElementById("book");
  const loading = document.getElementById("loading");
  const toggleBtn = document.getElementById("toggleView");
  const controls = document.querySelector(".controls");
  let current = 0;

  // Preload all images before building the book
  function preloadImages() {
    let loadedCount = 0;
    const images = [];

    return new Promise((resolve) => {
      for(let i = 1; i <= totalPages; i++) {
        const img = new Image();
        img.src = `page_${String(i).padStart(3, "0")}.png`;
        img.onload = () => {
          loadedCount++;
          if (loadedCount === totalPages) {
            resolve(images);
          }
        };
        img.onerror = () => {
          console.warn(`Failed to load image page_${String(i).padStart(3, "0")}.png`);
          loadedCount++;
          if (loadedCount === totalPages) {
            resolve(images);
          }
        };
        images.push(img);
      }
    });
  }

  preloadImages().then((images) => {
    loading.style.display = 'none';
    controls.style.display = 'block';
    book.style.display = 'block';

    images.forEach((img, i) => {
      const page = document.createElement("div");
      page.className = "page";
      page.style.zIndex = totalPages - i;

      const inner = document.createElement("div");
      inner.className = "page-inner";

      img.alt = `Page ${i+1}`;
      img.style.userSelect = 'none';
      img.style.webkitUserDrag = 'none';
      img.style.pointerEvents = 'none';

      inner.appendChild(img);
      page.appendChild(inner);
      book.appendChild(page);

      enableZoom(inner, img);
    });

    showPage(0);
  });

  function pages() {
    return document.querySelectorAll(".page");
  }

  function showPage(n) {
    if (n < 0 || n > totalPages) return;
    current = n;

    pages().forEach((page, idx) => {
      page.classList.toggle("flipped", idx < n);

      // Reset zoom and pan on page flip
      const img = page.querySelector('img');
      const inner = page.querySelector('.page-inner');
      img.style.transition = 'transform 0.3s ease';
      img.style.transform = 'translate(0,0) scale(1)';
      inner.dataset.scale = 1;
      inner.dataset.posX = 0;
      inner.dataset.posY = 0;
    });
  }

  document.querySelector(".nav.right").addEventListener("click", () => {
    if (current < totalPages) showPage(current + 1);
  });

  document.querySelector(".nav.left").addEventListener("click", () => {
    if (current > 0) showPage(current - 1);
  });

  toggleBtn.addEventListener("click", () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().then(() => {
        book.classList.add("fullscreen");
        toggleBtn.textContent = "Exit Fullscreen";
      });
    } else {
      document.exitFullscreen().then(() => {
        book.classList.remove("fullscreen");
        toggleBtn.textContent = "Enter Fullscreen";
      });
    }
  });

  function setViewportHeight() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }
  setViewportHeight();
  window.addEventListener('resize', setViewportHeight);

  function enableZoom(container, img) {
    // Initialize state on container dataset
    container.dataset.scale = 1;
    container.dataset.posX = 0;
    container.dataset.posY = 0;

    let lastTouchDistance = 0;
    let lastTouchCenter = null;
    let dragging = false;
    let lastX = 0, lastY = 0;

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function updateTransform() {
      const scale = parseFloat(container.dataset.scale);
      const posX = parseFloat(container.dataset.posX);
      const posY = parseFloat(container.dataset.posY);

      img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
    }

    function reset() {
      container.dataset.scale = 1;
      container.dataset.posX = 0;
      container.dataset.posY = 0;
      updateTransform();
    }

    function getDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function getCenter(touches) {
      return {
        x: (touches[0].clientX + touches[1].clientX) / 2,
        y: (touches[0].clientY + touches[1].clientY) / 2
      };
    }

    // Touch events
    container.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        lastTouchDistance = getDistance(e.touches);
        lastTouchCenter = getCenter(e.touches);
      } else if (e.touches.length === 1 && parseFloat(container.dataset.scale) > 1) {
        dragging = true;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
      }
    }, { passive: false });

    container.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();

        let newDistance = getDistance(e.touches);
        let newCenter = getCenter(e.touches);

        let scale = parseFloat(container.dataset.scale);
        let newScale = clamp(scale * (newDistance / lastTouchDistance), 1, 4);

        // Adjust pan to keep zoom centered on pinch center
        let posX = parseFloat(container.dataset.posX);
        let posY = parseFloat(container.dataset.posY);

        // Calculate the difference in center points scaled by new scale
        const dx = newCenter.x - lastTouchCenter.x;
        const dy = newCenter.y - lastTouchCenter.y;

        // Update position accordingly (adjusted for scale change)
        posX += dx;
        posY += dy;

        container.dataset.scale = newScale;
        container.dataset.posX = posX;
        container.dataset.posY = posY;

        lastTouchDistance = newDistance;
        lastTouchCenter = newCenter;

        clampPan();
        updateTransform();

      } else if (e.touches.length === 1 && dragging) {
        e.preventDefault();

        let posX = parseFloat(container.dataset.posX);
        let posY = parseFloat(container.dataset.posY);

        let dx = e.touches[0].clientX - lastX;
        let dy = e.touches[0].clientY - lastY;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;

        container.dataset.posX = posX + dx;
        container.dataset.posY = posY + dy;

        clampPan();
        updateTransform();
      }
    }, { passive: false });

    container.addEventListener('touchend', (e) => {
      if (e.touches.length === 0) {
        dragging = false;
      }
    });

    // Mouse events for pan & double click zoom
    container.addEventListener('mousedown', (e) => {
      if (parseFloat(container.dataset.scale) === 1) return;
      dragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      e.preventDefault();
    });

    window.addEventListener('mouseup', () => {
      dragging = false;
    });

    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      e.preventDefault();

      let posX = parseFloat(container.dataset.posX);
      let posY = parseFloat(container.dataset.posY);

      let dx = e.clientX - lastX;
      let dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;

      container.dataset.posX = posX + dx;
      container.dataset.posY = posY + dy;

      clampPan();
      updateTransform();
    });

    // Double click or double tap to toggle zoom
    let lastTapTime = 0;
    container.addEventListener('dblclick', (e) => {
      e.preventDefault();
      toggleZoom();
    });
    container.addEventListener('touchend', (e) => {
      const currentTime = new Date().getTime();
      const tapLength = currentTime - lastTapTime;
      if (tapLength < 300 && tapLength > 0) {
        e.preventDefault();
        toggleZoom();
      }
      lastTapTime = currentTime;
    });

    function toggleZoom() {
      const scale = parseFloat(container.dataset.scale);
      if (scale === 1) {
        container.dataset.scale = 2;
      } else {
        reset();
      }
      clampPan();
      updateTransform();
    }

    function clampPan() {
      const rect = container.getBoundingClientRect();
      const scale = parseFloat(container.dataset.scale);

      const maxX = (rect.width * (scale - 1)) / 2;
      const maxY = (rect.height * (scale - 1)) / 2;

      let posX = parseFloat(container.dataset.posX);
      let posY = parseFloat(container.dataset.posY);

      posX = clamp(posX, -maxX, maxX);
      posY = clamp(posY, -maxY, maxY);

      container.dataset.posX = posX;
      container.dataset.posY = posY;
    }
  }
</script>

</body>
</html>
